---
timezone: UTC+8
---


# kuove

1. 以太坊初学者
2. 你认为你会完成本次残酷学习吗？可以
3. Telegram：@stephkuove

## Notes

<!-- Content_START -->

### 2025.06.16

#### 单时隙最终确定性（Single Slot Finalty）及质押民主化
目前，需要 2-3 个 epoch（15 分钟左右）才能最终确定（finalize）一个区块，且需要 32 ETH 才能成为质押者。
最初这是为了在以下三个目标之间取得平衡而做出的妥协：

    1、最大化参与到质押中的验证者数量

    2、最小化最终确定时间

    3、最小化运行节点的开销，包括下载、验证和广播其他验证者签名的成本
这三个目标是相互冲突的

希望在理想情况下，保持经济终结性，同时在两个方面改善现状：

    1、在单时隙内最终确定区块（理想情况下，保持甚至减少当前 12 秒的时长），而不是 15 分钟

    2、允许验证者以 1 ETH 进行质押（原为 32 ETH）

存在的挑战
    更快的区块最终确定和更民主化质押的目标，但这都与最小化开销的目标相冲突。

如何做到
单时隙最终性涉及使用一种共识算法来最终确定一个时隙中的区块。
以太坊的独特特性需求是 inactivity leaks：即使超过 1/3 的验证器离线，该特性也允许链继续运行并最终恢复，
已经有提案修改了 Tendermint 共识以适应 inactivity leaks。

问题最难的部分是在验证者数量非常多时，单时隙的最终确定性如何正常工作，而不会导致节点的运营商产生极高的开销。
为此，有几种领先的解决方案
    暴力破解
    Orbit 委员会 —— 一种新机制，允许随机选取的中型委员会来负责链的最终确定性，但这是以一种我们想要的保留攻击成本特性的方式。
    双层质押 —— 一种有两类质押者的机制，一类质押者有较高的存款要求，另一类质押者有较低的存款要求。

还有什么要做，需要权衡什么？
有四种主要的可能路径可供选择（我们也可以采取混合路径）：

    1、维持现状
    2、暴力破解 SSF
    3、Orbit SSF
    4、有双层质押机制的 SSF

可以组合多种策略，例如：

（1+2）：添加 Orbit，但不进行单时隙最终确定。
（1+3）：使用强力技术减少最小存款规模，而无需进行单时隙最终确定。所需的聚合量比单纯使用（3）情况少 64 倍，这样一来问题变得更简单了。
（2+3）：使用保守参数（例如 128k 验证者委员会而不是 8k 或 32k）执行 Orbit SSF，并使用暴力破解技术使其极其高效。
（1+4）：增加彩虹质押而不执行单时隙最终确定

### 2025.06.17
#### 单一秘密领袖选举

哪个验证者将提出下一个区块是可以预知。会产生一个安全漏洞：攻击者可以进行 DoS 攻击。

如何做到

隐藏哪个验证者将生成下一个区块的信息，至少在区块实际生成之前要隐藏这些信息。
如果删除“单独”这一要求，一种解决方案是让任何人都可以创建下一个区块，但要求 randao 揭示小于 2^256 / N。平均而言，只有一个验证者能够满足此要求 —— 但有时会有两个或更多，有时会没有。

单一秘密领袖选举协议通过使用一些加密技术为每个验证者创建一个“盲”验证者 ID 来解决这个问题，然后让许多提议者有机会对盲 ID 池进行改组和重新盲化（这类似于混合网络的工作方式）。在每个时段，都会选择一个随机盲 ID。只有该盲 ID 的所有者才能生成有效的证明来提议区块，且没有人知道该盲 ID 对应的是哪个验证者。


#### 与现有研究有哪些联系？

Dan Boneh 的论文（Paper by Dan Boneh）（2020）：https://eprint.iacr.org/2020/025.pdf

Whisk（以太坊具体提案，2022）：https://ethresear.ch/t/whisk-a-practical-shuffle-based-ssle-protocol-for-ethereum/11763

在 ethresear.ch 的单一秘密领袖选举标签（Single secret leader election tag on ethresear.ch）：https://ethresear.ch/tag/single-secret-leader-election

使用环签名的简化 SSLE（Simplified SSLE using ring signatures）：https://ethresear.ch/t/simplified-ssle/12315


#### 还有什么要做，需要权衡什么？
需要找到并实现一个足够简单的协议，以便轻松地在主网上实现。我们高度重视保持以太坊协议的简易性，不希望进一步增加复杂性。
SSLE 仅用了数百行规范代码，并在复杂的加密中引入了新的假设。如何实现足够有效的抗量子 SSLE 也是一个问题。

最终可能会出现这样的情况：
只有当我们出于其他原因（例如状态树、ZK-EVM）大胆尝试并在 L1 的以太坊协议中引入执行通用零知识证明的机制时，SSLE 的“边际额外复杂性”才会下降到足够低的水平。

另一种选择是根本不理会 SSLE，而是使用协议外缓解措施（例如在 p2p 层）来解决 DoS 问题。

它如何与路线图的其他部分互动？

如果我们添加证明者-提议者分离（APS）机制，比如执行票证，因为我们可以依赖专门的区块构建器，那么执行区块（例如包含以太坊交易的区块）将不再需要 SSLE。不过，对于共识区块（包含协议消息的区块：比如证明、可能还有纳入列表的一些片段等），我们仍然可以从 SSLE 中受益。

#### 更快的交易确认

进一步缩短以太坊的交易确认时间（从 12 秒缩短到 4 秒）。
这样做将显著改善 L1 和基于 rollups 的用户体验，同时使 De-Fi 协议更加高效。
它还将使 L2 更易去中心化，因为它将允许大量 L2 应用程序在 based rollups 上运作，从而减少 L2 构建自己的基于委员会的去中心化排序的需求。

这里大致有两种技术：

减少时隙时间，降至如 8 秒或 4 秒。这并不一定意味着 4 秒的最终确定性：最终确定性本质上需要三轮通信，因此我们可以将每轮通信设为一个单独的区块，这将在 4 秒后至少得到初步确认。

允许提议者在单时隙期间发布预确认。在极端情况下，提议者可以实时将他们看到的交易纳入其区块，并立即为每笔交易发布预确认消息。
提议者发布两个相互冲突的确认的情况可以通过两种方式处理：
    （i）通过罚没（slashing）提议者
    （ii）通过使用证明人（attesters）投票选出哪一个更早。

与现有研究有？


### 2025.06.18

#### 执行层
Geth：由以太坊基金会直接资助的团队维护，使用 Go 语言开发，是公认的最稳定、久经考验的客户端
Nethermind：由 Nethermind 团队开发和维护，使用 C# 语言开发，早期获以太坊基金会和 Gitcoin 社区资助
Besu：最初由 ConsenSys 的 PegaSys 团队开发，现为 Hyperledger 社区项目，使用 Java 语言开发
Erigon：由 Erigon 团队开发和维护，获以太坊基金会、BNB Chain 资助。2017 年从 Geth 分叉而来，目标是提升同步速度和磁盘效率
Reth：由 Paradigm 主导开发，开发语言是 Rust，强调模块化和高性能，目前已经趋近成熟，可以在生产环境使用

#### 执行层简介
可以将以太坊执行层看作是一个由交易驱动的状态机，执行层最基础的职能就是通过 EVM 执行交易来更新状态数据。
除了交易执行之外，还有保存并验证区块和状态数据，运行 p2p 网络并维护交易池等功能。

交易由用户（或者程序）按照以太坊执行层规范定义的格式生成，用户需要对交易进行签名，如果交易是合法的（Nonce 连续、签名正确、gas fee 足够、业务逻辑正确），那么交易最终就会被 EVM 执行，从而更新以太坊网络的状态。这里的状态是指数据结构、数据和数据库的集合，包括外部账户地址、合约地址、地址余额以及代码和数据。

执行层负责执行交易以及维护交易执行之后的状态，共识层负责选择哪些交易来执行。EVM 则是这个状态机中的状态转换函数，函数的输入会来源于多个地方，有可能来源于共识层提供的最新区块信息，也有可能来源于 p2p 网络下载的区块。

共识层和执行层通过 Engine API 来进行通信，这是执行层和共识层之间唯一的通信方式。如果共识层拿到了出块权，就会通过 Engine API 让执行层产出新的区块，如果没有拿到出块权，就会同步最新的区块让执行层验证和执行，从而与整个以太坊网络保持共识。

执行层从逻辑上可以分为 6 个部分：

EVM：负责执行交易，交易执行也是修改状态数的唯一方式
存储：负责 state 以及区块等数据的存储
交易池：用于用户提交的交易，暂时存储，并且会通过 p2p 网络在不同节点之间传播
p2p 网络：用于发现节点、同步交易、下载区块等等功能
RPC 服务：提供访问节点的能力，比如用户向节点发送交易，共识层和执行层之间的交互
BlockChain：负责管理以太坊的区块链数据


![执行层的关键流程，以及每个部分的职能](https://forum.lxdao.io/uploads/default/original/2X/f/f0279126ef14fc319b2d92e35f8de6a7381f1073.png)
对于执行层，有三个关键流程：

如果是新加入以太坊的节点，需要通过 p2p 网络从其他的节点同步区块和状态数据，如果是 Full Sync，会从创世区块开始逐个下载区块，验证区块并通过 EVM 重建状态数据库，如果是 Snap Sync，则跳过全部区块验证的过程，直接下载最新 checkpoint 的状态数据和以后的区块数据
如果是已经同步到最新状态的节点，那么就会持续通过 Engine API 从共识层获取到当前最新产出的区块，并验证区块，然后通过 EVM 执行区块中所有的交易来更新状态数据库，并将区块写入本地链
如果是已经同步到最新状态，并且共识层拿到了出块权的节点，就会通过 Engine API 驱动执行层产出最新的区块，执行层从交易池获取交易并执行，然后组装成区块通过 Engine API 传递给共识层，由共识层将区块广播到共识层 p2p 网络


#### go-ethereumdede的代码结构
go-ethereum 的代码结构很庞大，但其中很多代码属于辅助代码和单元测试，在研究 Geth 源码时，只需要关注协议的核心实现，各个模块功能如下。
需要重点关注 core、eth、ethdb、node、p2p、rlp、trie & triedb 等模块：

    accounts：管理以太坊账户，包括公私钥对的生成、签名验证、地址派生等
    beacon：处理与以太坊信标链（Beacon Chain）的交互逻辑，支持权益证明（PoS）共识的合并（The Merge）后功能
    build：构建脚本和编译配置（如 Dockerfile、跨平台编译支持）
    cmd：命令行工具入口，包含多个子命令
    common：通用工具类，如字节处理、地址格式转换、数学函数
    consensus：定义consensus engine ，包括之前的工作量证明（Ethash）和单机权益证明（Clique）以及 Beacon engine 等
    console：提供交互式 JavaScript 控制台，允许用户通过命令行直接与以太坊节点交互（如调用 Web3 API、管理账户、查询区块链数据）
    core：区块链核心逻辑，处理区块/交易的生命周期管理、状态机、Gas计算等
    crypto：加密算法实现，包括椭圆曲线（secp256k1）、哈希（Keccak-256）、签名验证
    docs：文档（如设计规范、API 说明）
    eth：以太坊网络协议的完整实现，包括节点服务、区块同步（如快速同步、归档模式）、交易广播等
    ethclient：实现以太坊客户端库，封装 JSON-RPC 接口，供 Go 开发者与以太坊节点交互（如查询区块、发送交易、部署合约）
    ethdb：数据库抽象层，支持 LevelDB、Pebble、内存数据库等，存储区块链数据（区块、状态、交易）
    ethstats：收集并上报节点运行状态到统计服务，用于监控网络健康状态
    event：实现事件订阅与发布机制，支持节点内部模块间的异步通信（如新区块到达、交易池更新）
    graphql：提供 GraphQL 接口，支持复杂查询（替代部分 JSON-RPC 功能）
    internal：内部工具或限制外部访问的代码
    log：日志系统，支持分级日志输出、上下文日志记录
    mertrics：性能指标收集（Prometheus 支持）
    miner：挖矿相关逻辑，生成新区块并打包交易（PoW 场景下）
    node：节点服务管理，整合 p2p、RPC、数据库等模块的启动与配置
    p2p：点对点网络协议实现，支持节点发现、数据传输、加密通信
    params：定义以太坊网络参数（主网、测试网、创世区块配置）
    rlp：实现以太坊专用的数据序列化协议 RLP（Recursive Length Prefix），用于编码/解码区块、交易等数据结构
    rpc：实现 JSON-RPC 和 IPC 接口，供外部程序与节点交互
    signer：交易签名管理（硬件钱包集成）
    tests：集成测试和状态测试，验证协议兼容性
    trie & triedb：默克尔帕特里夏树（Merkle Patricia Trie）的实现，用于高效存储和管理账户状态、合约存储



<!-- Content_END -->
