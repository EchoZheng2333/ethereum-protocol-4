---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# wynn

1. 本人是一名接触web3一年多的后端程序员，目前正在一家小的dex团队负责后端相关的工作，主要技术栈是go，想深入了解并学习下以太坊协议相关知识，期望在未来能够为以太坊开发做出点贡献。
2. Absolutely!
3. TG: @wynn520

## Notes

<!-- Content_START -->

### 2025.06.16

#### 主要学习区块构建和交易执行流程

区块如何产生的？  

当共识层通过 engine API's fork choice updated 端点指示执行层客户端时，区块就被创建了，然后通过 payload building routine 启动区块构建过程。

每个时隙都有一个指定的区块提议者，通过共识层的伪随机过程选出。当一个验证者被选为某个时隙的区块提议者时，它的共识客户端通过执行引擎的fork choice updated方法启动区块构建过程，该方法提供了构建区块所需的上下文。

什么是时隙？
```text
以太坊中的“时隙”（slot）是其共识机制（自2022年“合并”后采用权益证明 PoS）中最基本的时间单位，固定为12秒。每个时隙对应一次区块生成机会，由随机选出的验证者负责提议新区块。
```

时隙的核心定义与作用？  
1.时间单位
 - 时隙是信标链（Beacon Chain）的最小时间划分单元，固定为12秒
 - 在理想网络条件下，每个时隙应生成一个新区块。若验证者离线或未及时提交，该时隙可能为空（“跳过时隙”）

2.区块产生机制
 - 区块提议者：每个时隙开始时，系统通过伪随机算法从验证者池中选出一名作为提议者，负责打包交易并创建新区块
 - 验证职责：其他验证者被分配为“证明者”（attesters），对提议的区块进行验证和投票，确保其有效性

下面是一个简化并模拟的区块构建过程：
```go
func build(env environment, pool txpool.Pool, state state.StateDB) (types.Block, state.StateDB) {
    var (
        gasUsed = 0
        txs []types.Transactions
    )

    for ; gasUsed < 30_000_000 || !pool.Empty(); {
        transaction := pool.Pop()
        res, gas, err := vm.Run(env, transaction, state)
        if err != nil {
            // transaction invalid
            continue
        }
        gasUsed += gas
        transactions = append(transactions, transaction)
    }
    return core.Finalize(env, transactions, state)
}
```
1.接收 3 个传参变量
 - env environment 包含环境所有必要信息，包括时间戳、区块编号、前置区块、基础费用以及需要在区块中发生的所有提取操作, 这些信息本质上来源于共识层。
 - 交易池 txpool.Pool 变量，即交易的集合，为简单起见，我们假设这些交易按其价值升序排列，价值越高的交易更容易被确认打包
 - state.StateDB 状态数据库表示执行这些交易的状态存储

最后生成并返回以下内容:

 - 一个完整的区块
 - 一个包含所有交易的状态数据库（state DB），它记录了所有交易的执行结果和更新后的状态
 - 如果在处理过程中出现了错误，还可能会返回一个错误信息

2. 在 build 函数中，我们跟踪 gas 消耗 gasUsed，因为我们可以使用的 gas 是有限的。我们还存储所有将被包含在区块中的交易。

3. 我们继续添加交易，直到交易池为空，或者消耗的 gas 超过 gas 限制。为了简单起见，在这个例子中，gas 限制设定为 3000 万（大约是主网当前的 gas 限制）。

4. 为了获取一笔交易，我们必须查询交易池，假设交易池会维护一个有序的交易列表，确保我们始终获取到下一个最有价值的交易。

5. 交易在 EVM 中执行，在执行交易时，系统将交易、环境和当前状态作为输入，并在这些输入条件下执行交易。交易的执行会根据当前环境（如区块链状态）进行，并在执行过程中更新状态数据库，包括所有已成功执行的交易

6. 如果交易执行失败，并且在执行过程中发生错误，我们将继续处理下一笔交易，而不立即中断。这表明该交易无效，并且由于区块中仍有未使用的 gas，我们不希望立即生成错误。因为在区块中尚未发生错误，因此我们可以继续进行处理。然而，很可能该交易是无效的，因为它在执行过程中发生了错误，或者交易池中的数据略有过时。在这种情况下，我们允许继续并尝试从交易池中获取下一笔交易，继续将其加入到当前区块中。

7. 一旦我们验证运行交易没有错误，我们就会将该交易添加到交易列表中，并将运行返回的气体添加到所使用的气体中。例如，如果第一笔交易是简单的转账，需要花费 21,000 Gas，那么我们使用的 Gas 将从 0 到 21,000，我们将继续执行此过程步骤 3-7，直到满足步骤 3 的条件

8. 我们通过获取一组交易和相关区块信息， 以最终确定生成一个完整的区块, 这样做的目的是为了最后进行一定的计算。由于 header 包含交易根、收据根和提款根，因此必须通过默克尔化列表来计算这些值并将其添加到块的 header 中。

<!-- Content_END -->
